---
title: "배열과 리스트"
author: Young Dean
date: 2021-05-11
categories: [CS]
tags: [CS, datastructure]
toc: true
toc_sticky: true
---

> 해당 게시물은 신찬수 교수님의 자료구조 강의를 듣고 이해한 내용을 바탕으로 작성하였습니다. 
> [링크](https://www.youtube.com/watch?v=Lqd8o7vL2Z8&list=PLsMufJgu5933ZkBCHS7bQTx0bncjwi4PK&index=6)

# 배열과 리스트

**배열**

```C++
int A[4] = {2,4,0,5};
A[2] = A[2] + 1;
//쓰기, 대입, 읽기, 산술 연산이 있음
```

- 읽기 쓰기 대입 산술 연산이 일어남
- ```A[0]```의 주소에 2라는 값이 저장되어있음
- 기본연산은 O(1) 만큼의 시간 복잡도를 가짐
- 만약 int형 배열인 A에서 ```A[2]```의 주소를 구하는 방법은 ```A[0]```의 주소에서 4bytes씩 2번 건너뛴 번지수가 됨
- ```index```로 배열의 특정 위치의 값을 산술시간 내에 읽고 쓸 수 있게 제공되는 자료구조
- 동적으로 용량을 조절하려면 따로 구현해야함.
- ```C```나 ```Java```언어 등에 있음

**리스트**

```Python
A = [2,4,0,5]
A[2] = A[2] + 1
A.append(6) # 맨 뒤에 6을 삽입
A.pop() # 맨 뒤의 값을 지우고 리턴
A.pop(1) # A[1]을 제거하고 리턴
A.insert(1,10) # A[1]에 10을 삽입
A.remove(value) # A에서 처음으로 나온 value 값을 찾아 제거
A.index(value) # A에서 처음으로 나온 value값의 인덱스 값을 리턴
A.count(value) # A에서 value값이 몇 개인지 리턴
```

- 2, 4, 0, 5는 각각 객체가 됨
- 위 예제에서 ```A[0]```는 2라는 값이 저장된 주소를 가리킴 <- 나는 이것이 제일 큰 차이점으로 느껴졌음
- ```A[2] = A[2] + 1``` 즉 왼쪽의 계산을 하면 결과는 1인데 1이라는 객체가 생기고 이걸 새롭게 가리키게 됨, 원래의 0이라는 객체는 어딘가에 남아는 있음
-  ```Python```에서 제공됨
- 리스트와 배열의 큰 차이점은 리스트는 용량 자동 조절이 가능하다.  복잡한 구현으로 이루어짐
